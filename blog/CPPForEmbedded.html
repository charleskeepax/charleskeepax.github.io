<!DOCTYPE html> <html> <head> <meta http-equiv="content-type" content="text/html; charset=utf-8"/> <meta http-equiv="content-language" content="en-gb"/> <meta name="language" content="english"/> <meta name="author" content="charles keepax"/> <meta name="robots" content="index, follow"/> <link rel="sitemap" href="/sitemap.xml" type="application/xml" title="Sitemap"/> <link rel="shortcut icon" href="/favicon.ico" type="image/vnd.microsoft.icon"/> <link rel="stylesheet" href="/styles/layout.css" type="text/css" media="screen"/> <link rel="stylesheet" href="/styles/m_layout.css" type="text/css" media="handheld, only screen and (max-device-width:480px)"/> <link rel="stylesheet" href="/styles/webblog.css" type="text/css" media="screen"/> <link rel="stylesheet" href="/styles/m_webblog.css" type="text/css" media="handheld, only screen and (max-device-width:480px)"/> <meta name="description" content="Charles Keepax's thoughts on using C++ in embedded system development."/> <meta name="keywords" content="charles keepax, charles, keepax, development,embedded,c++"/> <title>C++ for Embedded? - Charles Keepax</title> </head> <body> <div> <div id="title_container"> <h1>Charles Keepax's Blog</h1> <a id="feedlink" href="/atom.xml"><img src="/image/rss.svg" height="16" width="16" alt="Atom Feed"/></a> </div> <div id="sidebar_background"></div> <div id="column_container"> <div id="sidebar_container"> <ul class="nav_list"> <li class="nav_item"><div><a href="/index.html"><img class="spicon" src="/image/calendar.svg" height="12" width="12"/>Blog</a></div></li> <li><ol id="blogposts_sidebar" class="nav_list"> <li class="nav_item"><div> <a href="/blog/WebsiteIcons.html">Website Icons</a> </div></li> <li class="nav_item"><div> <a href="/blog/KeypressesFromJoystick.html">Keypresses From Joystick</a> </div></li> <li class="nav_item"><div> <a href="/blog/IntelHEXChecksumsInVim.html">Intel HEX Checksums in Vim</a> </div></li> <li class="nav_item"><div> <a href="/blog/CPPForEmbedded.html">C++ for Embedded?</a> </div></li> <li class="nav_item"><div> <a href="/blog/UltimateChilliRecipe.html">Ultimate Chilli Recipe?</a> </div></li> <li class="nav_item"><div><a href="/blog/archive.html">Blog Archive</a></div></li> <li class="nav_item"><div><a href="/blog/tags.html">Blog Tags</a></div></li> </ol></li> <li class="nav_item"><div><a href="/cv.html"><img class="spicon" src="/image/doc.svg" height="12" width="12"/>Curriculum Vitae</a></div></li> <li><ol class="nav_list"> <li class="nav_item"><div><a href="/cv.html#cv_profile">Profile</a></div></li> <li class="nav_item"><div><a href="/cv.html#cv_employmenthistory">Employment History</a></div></li> <li class="nav_item"><div><a href="/cv.html#cv_education">Education</a></div></li> <li class="nav_item"><div><a href="/cv.html#cv_publications">Publications</a></div></li> <li class="nav_item"><div><a href="/cv.html#cv_references">References</a></div></li> </ol></li> <li class="nav_item"><div><a href="/links.html"><img class="spicon" src="/image/link.svg" height="12" width="12"/>Links</a></div></li> <li><ol class="nav_list"> <li class="nav_item"><div><a href="https://bitbucket.org/charleskeepax">Bitbucket</a></div></li> <li class="nav_item"><div><a href="http://github.com/charleskeepax">Github</a></div></li> <li class="nav_item"><div><a href="http://uk.linkedin.com/pub/charles-keepax/24/b79/59a">LinkedIn</a></div></li> <li class="nav_item"><div><a href="http://stackoverflow.com/users/735744/charles-keepax">Stackoverflow</a></div></li> </ol></li> <li class="nav_item"><div> <a href="mailto:&#99;&#107;&#101;&#101;&#112;&#97;&#120;&#64;&#103;&#109;&#97;&#105;&#108;&#46;&#99;&#111;&#109;"><img class="spicon" src="/image/email.svg" height="12" width="12"/>Contact</a> </div></li> </ul> </div> <div id="content_container"> <div class="section"> <h2>C++ for Embedded?</h2> <div class="subsection"> <p>The term embedded system is rather vague, so it is perhaps prudent to narrow our field a little. Primarily, we are focusing on very small devices, that is development on small <abbr title="Digital Signal Processor">DSP</abbr> and microcontroller based systems running primarily out of the <abbr title="Central Processing Unit">CPU</abbr>'s internal memory. We shall discuss this scale of system mainly because use of C++ on a 32-bit <abbr title="Advanced RISC Machine">ARM</abbr> processor running linux is hardly contentious. These systems are about as small as you get and often bytes/clock cycles will count. Conventional wisdom generally dictates that we should avoid the use of C++ in such systems entirely, and stick to C and assembly. Personally I don't agree, but certainly C++ must be used with care and we will not build such a program using the same style and idioms we would for a desktop application.</p> <h3>It's a Terrible Idea!</h3> <p>Lets start out with a few reasons not to use C++. Firstly and most importantly you need to be sure there is good compiler support on your platform. Some processors will have no C++ compiler in which case you are stuffed. But even on those that do have support you need to be careful as a poor compiler is almost worse than no compiler at all.</p> <p>Also worth consideration is that in the embedded world you will likely work with a lot of electronic engineers many of them will have a basic to fairly decent grasp of C but little to no understanding of C++. This can be problematic when handing off your code for maintenance or if you team involves several sparkies who will be contributing on the software. Remember you should always assume that the person maintaining your code is prone to fits of rage, owns an axe and knows where you live. Make sure choosing C++ is not likely to become a maintenance nightmare for one of these axe murders.</p> <p>Well now that we have established that we have a fine upstanding compiler and a well educated team of crack programmers, we can proceed to why C++ is so awesome.</p> <h3>It's a Great Idea!</h3> <p>Templates, what's not to love about templates? They let us retain a high degree of flexibility in the final product with very little runtime cost. Additionally, they open up great additional code reuse options. Often I find myself reusing generic buffers, etc even within the same project. Templates are probably my favourite thing about using C++ for embedded work. And finally, templates let us do a lot more at compile time than we can in C, and the more done at compile time the less we have to squeeze into our tiny system at runtime. Interestingly there was a subset of C++ doing the rounds a while ago called <a href="http://en.wikipedia.org/wiki/Embedded_C%2B%2B">Embedded C++</a> which completely omitted templates, madness I tell you.</p> <p>C++ provides better language feature for arranging projects, especially as they get larger. I don't know whether it is the brainwashing of being educated through the staunchly object orientated part of history but I do like to have objects at my disposal whilst coding. Whilst somewhat moving out of vogue objects do map very well onto certain problems. C++ was written to include both procedural and object orientated styles and feel that is how it should be written, using objects when they enhance elegance of the code.</p> <h3>So Carefully You Say?</h3> <p>I make rather heavy use of static classes in my embedded code. A class containing only static methods and data behaves much like a collection of C functions, hence very little unnecessary overhead. Static classes also map well onto a lot of common embedded tasks. For example wrapping a hardware peripheral in an interface is a fairly common task, naturally the one peripheral only needs a single object to represent it. You could achieve the same effect using plain C, but I like having the opportunity to override parts of my interface to provide alternative functionality.</p> <p>Avoid exceptions and <abbr title="Run Time Type Information">RTTI</abbr>, they both add a lot of additional code footprint and are rarely necessary. Additionally, coming back to those poor sparkies it is worth noting that they have probably not heard of <abbr title="Resource Acquisition Is Initialisation">RAII</abbr>.</p> <p>Whilst I heaped praise on templates earlier they do have a darker side; templates can spew out quite the mountain of code if not used with care. Even worse this can be dependant on the compiler. You need to try to avoid generating additional code that is not required, for example the following small code snippet will often generate 2 copies of the Bar function even though both are identical. Clearly this should be taken care of by the optimizer, but a good amount of compilers will miss this one.</p> <p><script src="https://gist.github.com/1074075.js?file=code_duplication.cpp"></script></p> <p>Code that doesn't need to be duplicated can be filtered out into a non-templated base class, doing the optimizer's work for it. This allows us to keep the templated code, but only generate one copy of the Bar function.</p> <p><script src="https://gist.github.com/1074075.js?file=code_no_duplication.cpp"></script></p> <p>Try to push as much calculation to compile time as you can, templates are awesome for this. And keep a close eye on what your compiler is generating, sometimes you might need to do a little bit of work on its behalf. This actually comes up fairly often for me and I might try to write a post on annoying optimization differences in the future.</p> <p>Use polymorphism sparingly, virtual functions add both a small runtime and code footprint overhead. Whilst the penalty is small make sure that it is worth it, again as with templates keep a good eye on the compiled output to make sure nothing crazy it happening.</p> <h3>A Heap of Memory Allocation?</h3> <p>One thing I have been experimenting with recently is what happens if you allocate all memory on the stack? This means not using any new or delete allocated memory. Certainly when pushing the limits of a small processor it can become very competitive for memory which can make judging the sizes of the stack and heap rather important. Both the stack and heap need a good safety buffer on their size so eliminating one does make some degree of sense. This also has the advantage that stack based allocations are far more size deterministic, creating a much tighter bounded memory consumption. Furthermore, once new and delete are no longer used that code doesn't need to be included into the executable freeing up a good amount of code space as well.</p> <p>Obviously, entirely stack based allocation is not appropriate for all systems and please don't take this as me suggesting you should never allocate memory; if you need to use the heap please do. However, a fair amount of embedded work has fairly fixed quantities involved; I have X sensors, Y <abbr title="Serial Peripheral Bus">SPI</abbr> peripherals, rarely is it like a desktop system where hardware might be connected and disconnected. It is worth considering if you can get away with skipping the heap, you will save a good amount of code and data space.</p> <h3>So...</h3> <p>Well that is probably a deep enough journey into my crazy world for one day. I think the most important lesson to learn is that C++ has a lot to contribute to embedded projects, but please keep an eye on what the compiler is generating and which resources are in highest contention.</p> <p>EDIT: I have recently found this rather interesting <a href="http://altdevblogaday.com/2011/02/12/alternatives-to-malloc-and-new/">link</a> which discusses memory management in console games, I think a lot if relates well to what I was getting at in my discussion of heap memory allocation. <abbr title="For Your Information">FYI</abbr>, that is quite an interesting blog in general.</p> <div class="bp_footer"> <span class="rnote">Posted by <span class="bp_name">Charles Keepax</span> on <span class="bp_date">10/07/2011</span></span> <span class="bp_tags"> <img class="spicon" src="/image/tag.svg" height="16" width="16" alt="tags:"/> <a href="/blog/tags.html#bar_development">development</a> <a href="/blog/tags.html#bar_embedded">embedded</a> <a href="/blog/tags.html#bar_c++">c++</a> </span> </div> </div> </div> </div> <div id="footer_spacer"></div> </div> <div id="footer_container"> <p>Copyright &copy; Charles Keepax 2010-2022. All rights reserved. </div> </div> </body> </html>